"use strict";
/**
 * @packageDocumentation
 * @module Structures
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a page of tag list results, works like an array of {@link Tag}
 * <p> Usable like an array and allows to easily get the next page
 *
 * @example
 * ```
 * const Booru = require('booru')
 * // Safebooru
 * const sb = new Booru('sb')
 *
 * const tags = await sb.tagList()
 *
 * // Log the tags from the first page, then from the second
 * tags.forEach(t => console.log(t.name))
 * const tags2 = await tags.nextPage()
 * tags2.forEach(t => console.log(t.name))
 * ```
 */
class TagListResults extends Array {
    /** The booru used for this tag list */
    booru;
    /** The page of this tag list */
    page;
    /** The options used for this tag list */
    options;
    /** The tags from this tag list result */
    tags;
    /** @private */
    constructor(tags, options, booru) {
        super(tags.length);
        for (let i = 0; i < tags.length; i++) {
            this[i] = tags[i];
        }
        this.tags = tags;
        this.options = options;
        this.booru = booru;
        this.page = options ? (options.page ?? 0) : 0;
    }
    /**
     * Get the first tag in this result set
     * @return {Tag}
     */
    get first() {
        return this[0];
    }
    /**
     * Get the last tag in this result set
     * @return {Tag}
     */
    get last() {
        return this[this.length - 1];
    }
    /**
     * Get the next page of results
     * @returns {Promise<TagListResults>} The next page of results
     */
    async nextPage() {
        const nextPage = this.page + 1;
        const newTags = await this.booru.tagList({
            limit: this.options.limit,
            page: nextPage,
        });
        return new TagListResults(newTags, { ...this.options, page: nextPage }, this.booru);
    }
}
exports.default = TagListResults;
//# sourceMappingURL=TagListResults.js.map