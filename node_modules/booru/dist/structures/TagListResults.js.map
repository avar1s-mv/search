{"version":3,"file":"TagListResults.js","sourceRoot":"","sources":["../../src/structures/TagListResults.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAMH;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAqB,cAAe,SAAQ,KAAU;IACpD,uCAAuC;IAChC,KAAK,CAAO;IACnB,gCAAgC;IACzB,IAAI,CAAQ;IACnB,yCAAyC;IACzB,OAAO,CAAmB;IAC1C,yCAAyC;IACzB,IAAI,CAAO;IAE3B,eAAe;IACf,YAAY,IAAW,EAAE,OAA0B,EAAE,KAAY;QAC/D,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAElB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACnB,CAAC;QAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;QAClB,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;IAC/C,CAAC;IAED;;;OAGG;IACH,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,CAAC,CAAC,CAAA;IAChB,CAAC;IAED;;;OAGG;IACH,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;IAC9B,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,QAAQ;QACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,CAAA;QAC9B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;YACvC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK;YACzB,IAAI,EAAE,QAAQ;SACf,CAAC,CAAA;QACF,OAAO,IAAI,cAAc,CACvB,OAAO,EACP,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,EACnC,IAAI,CAAC,KAAK,CACX,CAAA;IACH,CAAC;CACF;AAxDD,iCAwDC","sourcesContent":["/**\n * @packageDocumentation\n * @module Structures\n */\n\nimport type Booru from '../boorus/Booru'\nimport type Tag from './Tag'\nimport type TagListParameters from './TagListParameters'\n\n/**\n * Represents a page of tag list results, works like an array of {@link Tag}\n * <p> Usable like an array and allows to easily get the next page\n *\n * @example\n * ```\n * const Booru = require('booru')\n * // Safebooru\n * const sb = new Booru('sb')\n *\n * const tags = await sb.tagList()\n *\n * // Log the tags from the first page, then from the second\n * tags.forEach(t => console.log(t.name))\n * const tags2 = await tags.nextPage()\n * tags2.forEach(t => console.log(t.name))\n * ```\n */\nexport default class TagListResults extends Array<Tag> {\n  /** The booru used for this tag list */\n  public booru: Booru\n  /** The page of this tag list */\n  public page: number\n  /** The options used for this tag list */\n  public readonly options: TagListParameters\n  /** The tags from this tag list result */\n  public readonly tags: Tag[]\n\n  /** @private */\n  constructor(tags: Tag[], options: TagListParameters, booru: Booru) {\n    super(tags.length)\n\n    for (let i = 0; i < tags.length; i++) {\n      this[i] = tags[i]\n    }\n\n    this.tags = tags\n    this.options = options\n    this.booru = booru\n    this.page = options ? (options.page ?? 0) : 0\n  }\n\n  /**\n   * Get the first tag in this result set\n   * @return {Tag}\n   */\n  get first(): Tag {\n    return this[0]\n  }\n\n  /**\n   * Get the last tag in this result set\n   * @return {Tag}\n   */\n  get last(): Tag {\n    return this[this.length - 1]\n  }\n\n  /**\n   * Get the next page of results\n   * @returns {Promise<TagListResults>} The next page of results\n   */\n  public async nextPage(): Promise<TagListResults> {\n    const nextPage = this.page + 1\n    const newTags = await this.booru.tagList({\n      limit: this.options.limit,\n      page: nextPage,\n    })\n    return new TagListResults(\n      newTags,\n      { ...this.options, page: nextPage },\n      this.booru,\n    )\n  }\n}\n"]}